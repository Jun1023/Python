정렬 : Data를 특정한 기준에 따라 순서대로 나열하는 것

컴퓨터는 인간과 다르게 규칙성을 직관적으로 알 수 없으며, 정렬을 어떻게 수행할지에 대해 코드로 작성하여 구체적으로 명시해야 한다.

=====================================================================================================================================================================

[선택 정렬(Selection Sort)]
- 모든 데이터를 탐색 후 가장 작은 데이터를 선택해 맨 앞의 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복함

[Selection Sort Code]

array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):
    min_index = i # 가장 작은 원소의 인덱스
    for j in range(i + 1, len(array)):
        if array[min_index] > array[j]:
            min_index = j
    array[i], array[min_index] = array[min_index], array[i] # swap

print(array) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


선택 정렬은 N-1번 만큼 가장 작은 수를 찾아 맨 앞으로 보내야 한다.
연산 횟수는 N + (N - 1) + (N - 2) + ... + 2 이다. => N * (N + 1) / 2 번의 연산을 수행한다고 볼 수 있다.
시간 복잡도 : O(n^2)

=====================================================================================================================================================================

[삽입 정렬(Insertion Sort)]
- 특정한 데이터를 적절한 위치에 '삽입'한다.

[Insertion Sort Code]

array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(1, len(array)):
    for j in range(i, 0, -1): # index i부터 1까지 감소하며 반복하는 문법
        if array[j] < array[j - 1]:
            array[j], array[j - 1] = array[j - 1], array[j] # swap

        else: # 자기보다 작은 데이터를 만나면 그 위치에 멈춤
            break

print(array) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


삽입 정렬은 선택 정렬과 똑같이 이중 for문을 사용하여 시간 복잡도가 O(n^2)지만 어느정도 정렬된 상태에서 진행한다면 매우 빠르게 동작한다.

최선의 시간 복잡도 : O(n)
시간 복잡도 : O(n^2)
# 거의 정렬된 상태로 입력이 주어지는 문제라면 삽입 정렬을 이용하는 것이 정답 확률을 높일 수 있다.

=====================================================================================================================================================================

[퀵 정렬(Quick Sort)]
- 기준을 설정한 다음 큰 수와 작은 수를 교환할 후 리스트를 반으로 나누는 방식으로 동작함
- 큰 숫자와 작은 숫자를 교활할 때, 교환하기 위한 '기준'을 피벗(Pivot)이라고 한다.

분할 방식인 호어 분할(Hoare Partition) : 리스트에서 첫 번째 데이터를 피벗으로 정한다.
피벗을 설정 후에는 왼쪽부터 피벗보다 큰 데이터를 찾고, 오른쪽부터 피벗보다 작은 데이터를 찾는다.
큰 데이터와 작은 데이터의 위치를 서로 교환해준다. 이런 과정을 반복하면 피벗에 대해 정렬이 수행된다.

[Quick Sort Code]

array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array, start, end):
    if start >= end: # 원소가 1개인 경우 종료
        return
    pivot = start # 피벗은 첫 번째 원소
    left = start + 1
    right = end
    while left <= right:
        while left <= end and array[left] <= array[pivot]:  # 피벗보다 큰 데이터를 찾을 때까지 반복
            left += 1

        while right > start and array[right] >= array[pivot]: # 피벗보다 작은 데이터를 찾을 때까지 반복
            right -= 1

        if left > right: # 엇갈렸다면 작은 데이터와 피벗을 교체
            array[right], array[pivot] = array[pivot], array[right] # Swap
        else: # 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
            array[left], array[right] = array[right], array[left]
    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
    quick_sort(array, start, right - 1)
    quick_sort(array, right + 1, end)

quick_sort(array, 0, len(array) - 1)
print(array) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


평균 시간 복잡도 : O(n log n)
최악의 경우 시간 복잡도 : O(n^2)
데이터의 개수가 많을 수록 다른 정렬 방법과는 차이가 심하다(훨씬 빨라진다)

=====================================================================================================================================================================

[계수 정렬(Count Sort)]

- 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘
데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때만 사용할 수 있다.
* 데이터의 값이 무한한 범위를 가질 수 있는 실수형 데이터가 주어지는 경우 계수 정렬을 사용하기 어렵다.
일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 100만을 넘지 않을 때 효과적으로 사용할 수 있다.

계수 정렬을 이용할 때는 '모든 범위를 담을 수 있는 크기의 리스트(배열)를 선언' 해야 한다.

리스트에 각 번호마다 몇 번 나왔는지 카운트해서 넣어주는 정렬 알고리즘이다.


최악의 경우 시간 복잡도 : O(n + K)	
* K는 데이터 중 최댓 값

공간 복잡도 : O(n + K)

[Count Sort Code]

array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]

count = [0] * (max(array) + 1)

for i in range(len(array)):
    count[array[i]] += 1 # 각 데이터에 해당하는 인덱스의 값 증가

for i in range(len(count)): # 리스트에 기록된 정렬 정보 확인
    for j in range(count[i]):
        print(i, end=' ') # 띄워쓰기를 구분으로 등장한 횟수만큼 인덱스 출력

# 0 0 1 1 2 2 3 4 5 5 6 7 8 9 9

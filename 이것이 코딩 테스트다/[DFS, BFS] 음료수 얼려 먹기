Q. 
  
   graph를 입력받고, 현재 노드에서 인접한 노드에 방문하지 않은 노드가 있는지 탐색하는 문제이다. DFS를 사용했다.
   
   입력 조건
    1. 첫 번째 줄에 얼음 틀의 세로 길이 N과 가로 길이 M이 주어진다. ( 1 <= N, M <= 1,000 )
    2. 두 번째 줄부터 N + 1번째 줄까지 얼음 틀의 형태가 주어진다.
    3. 이때 구멍에 뚫려있는 부분은 0, 그렇지 않은 부분은 1이다.
   
   출력 조건
    1. 한 번에 만들 수 있는 아이스크림의 개수를 출력한다.
    
   [입력]
   
   15 14
   00000111100000
   11111101111110
   11011101101110
   11011101100000
   11011111111111
   11011111111100
   11000000011111
   01111111111111
   00000000011111
   01111111111000
   00000001111000
   11111111110011
   11100011111111
   11100011111111
   
   
   [출력]
   
   8
   
  [풀이]

   인접 노드를 탐색하기 위해 DFS 함수를 만든다.
   노드의 상(x+1), 하(x-1), 좌(y-1), 우(y+1)를 살핀 후 주변 노드 중 값이 '0'(=아직 방문하지 않은 노드)이 있다면 해당 노드를 방문한다.
   재귀 함수를 통해 이동한 노드도 탐색한다.
   주변의 모든 노드에 '0'이 없다면 탐색을 마친다.
   모든 노드를 한 번씩 체크한다.

  [Book + My Code]

  from sys import stdin

  graph = []

  N, M = map(int, stdin.readline().split()) # N x M 크기의 틀을 만들기 위해 입력받음

  for _ in range(N): # N-1번 박복하여
      graph.append(list(map(int, input()))) # graph를 입력받는다.


  def DFS(x, y): # 재귀함수를 사용해 탐색하는 DFS를 사용한다.
      if x >= N or x <= -1 or y >= M or y <= -1: # graph 범위를 벗어난다면
          return False

      if graph[x][y] == 0: # 방문하지 않은 노드라면
          graph[x][y] = 1 # 방문처리

          # 인접한 노드 탐색
          DFS(x - 1, y)
          DFS(x, y - 1)
          DFS(x + 1, y)
          DFS(x, y + 1)
          return True # True 반환
      return False # if문에 해당하지 않는다면 False 반환


  result = 0 # 결과값을 넣을 변수
  for i in range(N):
      for j in range(M):
          if DFS(i, j) == True: # DFS 탐색하여 True값이 반환된다면
              result += 1 # 탐색을 마친 후 근처에 0인 값이 없는 경우니(= 음료수가 꽉 찼으니) result값에 1을 증가시킨다.

  print(result) # 탐색을 모두 마친 후 result값 출력


  * 탐색 문제를 한 번도 풀어보지 않아, 어떻게 풀어야할지는 알지만 코드로 구현할 수 없었다. 책에 나오는 코드를 손코딩 해보고, 이해한 후 문제를 다시 읽고 직접 코딩해서 성공했다.
  * 탐색 문제를 많이 풀어보면 익수해질 것 같다.
